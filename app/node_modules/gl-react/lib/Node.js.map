{"version":3,"sources":["../src/Node.js"],"names":["blendFuncAliases","zero","one","isBackbuffer","obj","console","warn","Backbuffer","isBackbufferFrom","type","isTextureSizeGetter","nodeWidthHeight","width","height","glSizable","getGLSize","cw","ch","mapBlendFunc","gl","name","id","parseWrap","w","CLAMP_TO_EDGE","REPEAT","MIRRORED_REPEAT","mergeArrays","a","b","t","length","Math","max","i","parseInterpolation","LINEAR","NEAREST","createFBO","handle","createFramebuffer","bindFramebuffer","FRAMEBUFFER","color","createTexture","Error","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","framebufferTexture2D","COLOR_ATTACHMENT0","bind","viewport","syncSize","h","dispose","deleteFramebuffer","deleteTexture","defaultTextureOptions","interpolation","wrap","applyTextureOptions","partialOpts","opts","filter","wrapS","wrapT","Array","isArray","NodePropTypes","shader","object","isRequired","uniformsOptions","uniforms","sync","bool","number","children","any","backbuffering","blendFunc","clear","onDraw","func","Node","drawProps","props","_needsRedraw","uniformsBus","dependencies","dependents","_resolveElement","uniform","value","index","isValidElement","redraw","_renderUniformElement","key","map","v","forEach","d","flush","context","glSurface","_draw","glParent","_prepareGLObjects","_addGLNodeChild","capturePixelsArray","_destroyGLObjects","freeUint8","_removeGLNodeChild","_removeDependent","nextProps","nextContext","_syncNextDrawProps","nextWidthHeight","framebuffer","backbuffer","RenderLessElement","Object","keys","shaderName","getShortName","getName","patch","x","y","undefined","size","pixels","_captureAlloc","_bind","readPixels","step","transpose","glIsAvailable","_shader","getGLName","fbo","_onContextLost","_onContextRestored","node","uniformBus","uniformName","array","indexOf","push","splice","newdeps","olddeps","additions","deletions","_addDependent","_bindRootNode","mallocUint8","shaderProp","nodeName","_getShader","shaderInfo","latestShaderInfo","_latestShaderInfo","_makeShader","visitors","getVisitors","onNodeDrawSkipped","nw","nh","types","glRedrawableDependencies","pendingTextures","units","usedUniforms","providedUniforms","k","textureUnits","Map","prepareTexture","initialObj","uniformOptions","uniformKeyName","dependency","result","glNode","glNodePickBackbuffer","getGLRenderableNode","renderable","getGLRenderableContent","directTexture","_resolveTextureLoader","loader","input","get","directTextureSize","getSize","load","promise","textureOptions","getMetaInfo","fallback","prepare","texture","getGLBackbufferOutput","getGLOutput","getEmptyTexture","has","activeTexture","TEXTURE0","set","prepareUniform","uniformType","uniformValue","Resolution","ratio","values","all","reduce","acc","o","concat","preparedUniforms","u","join","Promise","then","onNodeDrawStart","_syncDependencies","onNodeSyncDeps","drawDep","onNodeDraw","src","dst","clearColor","COLOR_BUFFER_BIT","drawArrays","TRIANGLES","onNodeDrawEnd","propTypes","defaultProps","contextTypes","childContextTypes"],"mappings":"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","file":"Node.js","sourcesContent":["//@flow\nimport invariant from \"invariant\";\nimport React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport pool from \"typedarray-pool\";\nimport ndarray from \"ndarray\";\nimport Uniform from \"./Uniform\";\nimport Bus from \"./Bus\";\nimport Shaders, {\n  isShaderIdentifier,\n  ensureShaderDefinition,\n  shaderDefinitionToShaderInfo,\n  shaderInfoEquals\n} from \"./Shaders\";\nimport invariantNoDependentsLoop from \"./helpers/invariantNoDependentsLoop\";\nimport genId from \"./genId\";\nimport type { Shader } from \"gl-shader\";\nimport type { NDArray } from \"ndarray\";\nimport type { ShaderIdentifier, ShaderInfo, ShaderDefinition } from \"./Shaders\";\nimport type { Surface, SurfaceContext } from \"./createSurface\";\n\nconst blendFuncAliases = {\n  zero: \"ZERO\",\n  one: \"ONE\",\n  \"src color\": \"SRC_COLOR\",\n  \"one minus src color\": \"ONE_MINUS_SRC_COLOR\",\n  \"src alpha\": \"SRC_ALPHA\",\n  \"one minus src alpha\": \"ONE_MINUS_SRC_ALPHA\",\n  \"dst color\": \"DST_COLOR\",\n  \"one minus dst color\": \"ONE_MINUS_DST_COLOR\",\n  \"dst alpha\": \"DST_ALPHA\",\n  \"one minus dst alpha\": \"ONE_MINUS_DST_ALPHA\",\n  \"constant color\": \"CONSTANT_COLOR\",\n  \"one minus constant color\": \"ONE_MINUS_CONSTANT_COLOR\",\n  \"constant alpha\": \"CONSTANT_ALPHA\",\n  \"one minus constant alpha\": \"ONE_MINUS_CONSTANT_ALPHA\",\n  \"src alpha saturate\": \"SRC_ALPHA_SATURATE\"\n};\n\n/**\n * The texture pixel interpolation mode.\n *\n * One of:\n * - `linear`\n * - `nearest`\n */\ntype Interpolation = \"linear\" | \"nearest\";\n\n/**\n * A texture wrap mode define how the texture lookup repeat over edges.\n *\n * One of:\n * - `clamp to edge`\n * - `repeat`\n * - `mirrored repeat`\n */\ntype WrapMode = \"clamp to edge\" | \"repeat\" | \"mirrored repeat\";\n\n/**\n * Options on a texture.\n * - interpolation define how the pixel lookup get mapped to screen.\n * - wrap define how the edge lookup behaves. It can be either a [x,y] wrap or a wrap value for both.\n */\ntype TextureOptions = {\n  interpolation: Interpolation,\n  wrap: [WrapMode, WrapMode] | WrapMode\n};\n\n/**\n * The GL blending function.\n *\n * One of:\n * - `zero`\n * - `one`\n * - `src color`\n * - `one minus src color`\n * - `src alpha`\n * - `one minus src alpha`\n * - `dst color`\n * - `one minus dst color`\n * - `dst alpha`\n * - `one minus dst alpha`\n * - `constant color`\n * - `one minus constant color`\n * - `constant alpha`\n * - `one minus constant alpha`\n * - `src alpha saturate`\n */\ntype BlendFunc = $Keys<typeof blendFuncAliases>;\n\n/**\n *\n */\ntype BlendFuncSrcDst = {|\n  src: BlendFunc,\n  dst: BlendFunc\n|};\n\n/**\n * Array of 4 numbers. Useful to represent colors. *[ r, g, b, a ]*\n */\ntype Vec4 = [number, number, number, number];\n\n/**\n * The GL clear mode.\n */\ntype Clear = {|\n  color: Vec4\n|};\n\n/**\n * Uniforms is an map object from uniform name to a value.\n *\n * **The library support numerous uniform types via different formats.\n * Let's describe them:**\n *\n * ### int or float\n *\n * a JavaScript number\n *\n * ### bool\n *\n * a JavaScript Boolean\n *\n * ### int[], float[], bool[] arrays\n *\n * an array of the number (0/1 for bool can be used as well as bools)\n *\n * ### vec2, vec3, vec4\n *\n * an array of number, of size respectively 2, 3 and 4.\n *\n * > same is available for ivec* variants.\n *\n * ### mat2, mat3, mat4\n *\n * Similarly to vectorial types, you can pass an array of numbers.\n * For matrix, you actually define them in a flatten way (not arrays of arrays).\n *\n * ### sampler2D type (aka texture)\n *\n * The library support numerous and extensible uniform value format.\n *\n * **FIXME: to be documented.**\n *\n * ### struct types\n *\n * Consider it unsupported even though it *might* work since gl-react is based on `gl-shader`.\n *\n */\ntype Uniforms = {\n  [_: string]: mixed\n};\n\ntype UniformsOptions = {\n  [_: string]: ?$Shape<TextureOptions>\n};\n\ntype Props = {|\n  shader: ShaderIdentifier | ShaderDefinition,\n  uniformsOptions: UniformsOptions,\n  uniforms: Uniforms,\n  sync?: boolean,\n  width?: number,\n  height?: number,\n  children?: any,\n  backbuffering?: boolean,\n  blendFunc: BlendFuncSrcDst,\n  clear: ?Clear,\n  onDraw?: () => void\n|};\n\n// not sure why, but we must define this for Flow to properly type check\ntype DefaultProps = {\n  uniformsOptions: UniformsOptions,\n  uniforms: Uniforms,\n  blendFunc: BlendFuncSrcDst,\n  clear: ?Clear\n};\n\ntype AsyncMixed = (redraw?: () => void) => mixed;\n\nconst isBackbuffer = (obj: *) => {\n  if (obj === \"Backbuffer\") {\n    console.warn(\n      'Backbuffer is deprecated, use Uniform.Backbuffer instead: `import {Uniform} from \"gl-react\"`'\n    );\n    return true;\n  }\n  return obj === Uniform.Backbuffer;\n};\n\nconst isBackbufferFrom = (obj: *) =>\n  obj && typeof obj === \"object\" && obj.type === \"BackbufferFrom\";\n\nconst isTextureSizeGetter = (obj: *) =>\n  obj && typeof obj === \"object\" && obj.type === \"TextureSize\";\n\nconst nodeWidthHeight = (\n  { width, height }: Props,\n  { glSizable }: SurfaceContext\n): [number, number] => {\n  if (width && height) return [width, height];\n  const [cw, ch] = glSizable.getGLSize();\n  return [width || cw, height || ch];\n};\n\nconst mapBlendFunc = (gl: WebGLRenderingContext, name: BlendFunc): ?number => {\n  // $FlowFixMe\n  if (name in gl) return gl[name];\n  if (name in blendFuncAliases) {\n    const id = blendFuncAliases[name];\n    // $FlowFixMe\n    if (id in gl) return gl[id];\n  }\n  console.warn(\"Invalid blendFunc. Got:\", name);\n};\n\nconst parseWrap = (gl: WebGLRenderingContext, w: string): number => {\n  switch (w) {\n    case \"clamp to edge\":\n      return gl.CLAMP_TO_EDGE;\n    case \"repeat\":\n      return gl.REPEAT;\n    case \"mirrored repeat\":\n      return gl.MIRRORED_REPEAT;\n    default:\n      console.warn(\"Invalid wrap. Got:\", w);\n      return gl.CLAMP_TO_EDGE;\n  }\n};\n\nconst mergeArrays = (a: Array<*>, b: Array<*>): Array<*> => {\n  const t = [];\n  const length = Math.max(a.length, b.length);\n  for (let i = 0; i < length; i++) {\n    t[i] = b[i] || a[i];\n  }\n  return t;\n};\n\nconst parseInterpolation = (gl: WebGLRenderingContext, i: string): number => {\n  switch (i) {\n    case \"linear\":\n      return gl.LINEAR;\n    case \"nearest\":\n      return gl.NEAREST;\n    default:\n      console.warn(\"Invalid interpolation. Got:\", i);\n      return gl.LINEAR;\n  }\n};\n\ntype Framebuffer = {\n  handle: WebGLFramebuffer,\n  color: WebGLTexture,\n  bind: () => void,\n  dispose: () => void,\n  syncSize: (w: number, h: number) => void\n};\n\n// minimal version of gl-fbo\nconst createFBO = (\n  gl: WebGLRenderingContext,\n  width: number,\n  height: number\n): Framebuffer => {\n  var handle = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, handle);\n  var color = gl.createTexture();\n  if (!color) throw new Error(\"createTexture returned null\");\n  gl.bindTexture(gl.TEXTURE_2D, color);\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    0,\n    gl.RGBA,\n    width,\n    height,\n    0,\n    gl.RGBA,\n    gl.UNSIGNED_BYTE,\n    null\n  );\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    color,\n    0\n  );\n  return {\n    handle,\n    color,\n    bind: () => {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, handle);\n      gl.viewport(0, 0, width, height);\n    },\n    syncSize: (w: number, h: number) => {\n      if (w !== width || h !== height) {\n        width = w;\n        height = h;\n        gl.bindTexture(gl.TEXTURE_2D, color);\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          0,\n          gl.RGBA,\n          w,\n          h,\n          0,\n          gl.RGBA,\n          gl.UNSIGNED_BYTE,\n          null\n        );\n      }\n    },\n    dispose: () => {\n      gl.deleteFramebuffer(handle);\n      gl.deleteTexture(color);\n    }\n  };\n};\n\nconst defaultTextureOptions: TextureOptions = {\n  interpolation: \"linear\",\n  wrap: [\"clamp to edge\", \"clamp to edge\"]\n};\n\nconst applyTextureOptions = (\n  gl: WebGLRenderingContext,\n  partialOpts: ?$Shape<TextureOptions>\n) => {\n  const opts: TextureOptions = { ...defaultTextureOptions, ...partialOpts };\n  let filter = parseInterpolation(gl, opts.interpolation);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n  let wrapS, wrapT;\n  if (Array.isArray(opts.wrap)) {\n    if (opts.wrap.length !== 2) {\n      console.warn(\n        \"textureOptions wrap: should be an array of 2 values. Got:\",\n        opts.wrap\n      );\n      wrapS = wrapT = gl.CLAMP_TO_EDGE;\n    } else {\n      wrapS = parseWrap(gl, opts.wrap[0]);\n      wrapT = parseWrap(gl, opts.wrap[1]);\n    }\n  } else {\n    wrapS = wrapT = parseWrap(gl, opts.wrap);\n  }\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n};\n\nconst NodePropTypes = {\n  shader: PropTypes.object.isRequired,\n  uniformsOptions: PropTypes.object,\n  uniforms: PropTypes.object,\n  sync: PropTypes.bool,\n  width: PropTypes.number,\n  height: PropTypes.number,\n  children: PropTypes.any,\n  backbuffering: PropTypes.bool,\n  blendFunc: PropTypes.object,\n  clear: PropTypes.object,\n  onDraw: PropTypes.func\n};\n\n/**\n * `<Node>` is the primitive that renders a shader program into a Framebuffer.\n * It can be composed with other `Node` via using a sampler2D uniforms.\n *\n * @prop {ShaderIdentifier} shader - created with `Shaders.create`\n * @prop {Uniforms} [uniforms] - uniform values that gets passed to the fragment shader.\n * @prop {Object} [uniformsOptions] - allows to configure things like interpolation of a sampler2D texture.\n * @prop {number} [width] - the width in in real pixels unit (unlike Surface, no pixel ratio)\n * @prop {number} [height] - the height in in real pixels unit (unlike Surface, no pixel ratio)\n * @prop {bool} [sync] - If true, a React update will always force a sync redraw of the Node framebuffer.\n * @prop {bool} [backbuffering] - enable the backbuffering that allows to use `Backbuffer` in uniforms to get the previous framebuffer texture state in the fragment shader.\n * @prop {BlendFuncSrcDst} [blendFunc] - configure the blending function to use\n * @prop {Clear} [clear] - configure the clear to use (color,...)\n * @prop {Function} [onDraw] - a callback called each time a draw was produced for this Node.\n * @prop {any} [children] - in advanced use-cases, you can render things like Bus or contents to be used by Node\n * @example\n *  <Node shader={shaders.helloGL} />\n */\nexport default class Node extends Component {\n  props: Props;\n  drawProps: Props = this.props;\n  context: SurfaceContext;\n  framebuffer: ?Framebuffer;\n  backbuffer: ?Framebuffer;\n  _needsRedraw: boolean = false;\n  capturePixelsArray: ?Uint8Array;\n  id: number = genId();\n  uniformsBus: { [key: string]: Array<?Bus> } = {};\n  dependencies: Array<Node | Bus> = []; // Node this instance depends on\n  dependents: Array<Node | Surface> = []; // Node/Surface that depends on this instance\n\n  static propTypes = NodePropTypes;\n\n  static defaultProps: DefaultProps = {\n    uniformsOptions: {},\n    uniforms: {},\n    blendFunc: {\n      // FIXME should this actually just be null by default? opt-in?\n      src: \"src alpha\",\n      dst: \"one minus src alpha\"\n    },\n    clear: {\n      color: [0, 0, 0, 0]\n    }\n  };\n\n  static contextTypes = {\n    glParent: PropTypes.object.isRequired,\n    glSurface: PropTypes.object.isRequired,\n    glSizable: PropTypes.object.isRequired\n  };\n\n  static childContextTypes = {\n    glParent: PropTypes.object.isRequired,\n    glSizable: PropTypes.object.isRequired\n  };\n\n  getChildContext() {\n    return {\n      glParent: this,\n      glSizable: this\n    };\n  }\n\n  componentWillMount() {\n    const { glSurface: { gl } } = this.context;\n    if (gl) this._prepareGLObjects(gl);\n  }\n\n  componentDidMount() {\n    this.context.glParent._addGLNodeChild(this);\n    this.redraw();\n    if (this.props.sync) this.flush();\n  }\n\n  componentWillUnmount() {\n    const { capturePixelsArray } = this;\n    this._destroyGLObjects();\n    if (capturePixelsArray) {\n      pool.freeUint8(capturePixelsArray);\n    }\n    this._needsRedraw = false;\n    this.context.glParent._removeGLNodeChild(this);\n    this.dependencies.forEach(d => d._removeDependent(this));\n  }\n\n  componentWillReceiveProps(nextProps: Props, nextContext: *) {\n    this._syncNextDrawProps(nextProps, nextContext);\n  }\n\n  _syncNextDrawProps(nextProps: Props, nextContext: *) {\n    const nextWidthHeight = nodeWidthHeight(nextProps, nextContext);\n    if (this.framebuffer) {\n      this.framebuffer.syncSize(...nextWidthHeight);\n    }\n    if (this.backbuffer) {\n      this.backbuffer.syncSize(...nextWidthHeight);\n    }\n    invariant(\n      nextProps.backbuffering === this.drawProps.backbuffering,\n      \"Node backbuffering prop must not changed. (not yet supported)\"\n    );\n    this.drawProps = nextProps;\n  }\n\n  _resolveElement = (\n    uniform: string,\n    value: mixed,\n    index: number\n  ): ?React.Element<*> => {\n    if (!React.isValidElement(value)) {\n      if (typeof value === \"function\") {\n        value = (value: AsyncMixed)(this.redraw);\n        if (!React.isValidElement(value)) {\n          return; // the function don't return an Element, skip\n        }\n      } else {\n        return; // the value isn't an Element, skip\n      }\n    }\n    return (\n      <Bus\n        key={uniform + (index ? \".\" + index : \"\")}\n        uniform={uniform}\n        index={index}\n      >\n        {value}\n      </Bus>\n    );\n  };\n\n  _renderUniformElement = (key: string) => {\n    const { uniforms } = this.props;\n    let value = uniforms[key];\n    return Array.isArray(value)\n      ? value.map((v, i) => this._resolveElement(key, v, i))\n      : this._resolveElement(key, value, 0);\n  };\n\n  render() {\n    const { children, uniforms } = this.props;\n    const { glSurface: { RenderLessElement } } = this.context;\n    return (\n      <RenderLessElement>\n        {children}\n        {Object.keys(uniforms).map(this._renderUniformElement)}\n      </RenderLessElement>\n    );\n  }\n\n  componentDidUpdate() {\n    this.redraw();\n    if (this.props.sync) this.flush();\n  }\n\n  getGLShortName(): string {\n    const { shader } = this.drawProps;\n    const shaderName = isShaderIdentifier(shader)\n      ? // $FlowFixMe FIXME\n        Shaders.getShortName(shader)\n      : \"<inline>\";\n    return `Node(${shaderName})`;\n  }\n\n  getGLName(): string {\n    const { shader } = this.drawProps;\n    const shaderName = isShaderIdentifier(shader)\n      ? // $FlowFixMe FIXME\n        Shaders.getName(shader)\n      : \"<inline>\";\n    return `Node#${this.id}(${shaderName})`;\n  }\n\n  getGLSize(): [number, number] {\n    return nodeWidthHeight(this.drawProps, this.context);\n  }\n\n  getGLOutput(): WebGLTexture {\n    const { framebuffer } = this;\n    invariant(\n      framebuffer,\n      \"Node#getGLOutput: framebuffer is not defined. It cannot be called on a root Node\"\n    );\n    return framebuffer.color;\n  }\n\n  getGLBackbufferOutput(): WebGLTexture {\n    const { backbuffer } = this;\n    invariant(\n      backbuffer,\n      \"Node#getGLBackbufferOutput: backbuffer is not defined. Make sure `backbuffering` prop is defined\"\n    );\n    return backbuffer.color;\n  }\n\n  /**\n   * Imperatively set the props with a partial subset of props to apply.\n   * This is an escape hatch to perform a redraw with different props without having to trigger a new React draw. Only use it when reaching a performance bottleneck.\n   * NB: at any time, render() needs to consistently render the same props you set in setDrawProps to avoid any potential blink (if a React draw would occur).\n   * @param {Props} patch a subset of props to apply on top of the previous draw props.\n   */\n  setDrawProps(patch: $Shape<Props>) {\n    // $FlowFixMe\n    const nextProps: Props = {\n      ...this.drawProps,\n      ...patch\n    };\n    this._syncNextDrawProps(nextProps, this.context);\n    this.redraw();\n    if (nextProps.sync) this.flush();\n  }\n\n  /**\n   * Capture the node pixels.\n   * Without parameters, it will capture the full rectangle,\n   * otherwise you can provide (x, y) or (x, y, w, h) to provide a subset of this rectangle.\n   */\n  capture(x?: number, y?: number, w?: number, h?: number): NDArray {\n    const [width, height] = this.getGLSize();\n    const { gl } = this.context.glSurface;\n    invariant(gl, \"gl is no longer available\");\n    if (x === undefined) x = 0;\n    if (y === undefined) y = 0;\n    if (w === undefined) w = width - x;\n    if (h === undefined) h = height - y;\n    invariant(\n      x >= 0 && x + w <= width && y >= 0 && y + h <= height,\n      \"capture(%s,%s,%s,%s): requested rectangle is out of bounds (%s,%s)\",\n      x,\n      y,\n      w,\n      h,\n      width,\n      height\n    );\n    const size = w * h * 4;\n    const pixels: Uint8Array = this._captureAlloc(size);\n    this._bind();\n    gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    return ndarray(pixels, [h, w, 4]).step(-1, 1, 1).transpose(1, 0, 2);\n  }\n\n  /**\n   * Schedule a redraw of this node and all dependent nodes.\n   *\n   * @function\n   */\n  redraw = (): void => {\n    if (!this._needsRedraw) {\n      this._needsRedraw = true;\n      this.dependents.forEach(d => d.redraw());\n    }\n  };\n\n  /**\n   * Force the redraw (if any) to happen now, synchronously.\n   *\n   * @function\n   */\n  flush = (): void => {\n    this.context.glSurface._draw();\n  };\n\n  _destroyGLObjects(): void {\n    const { glSurface } = this.context;\n    if (glSurface.glIsAvailable()) {\n      // We should only dispose() if gl is still here.\n      // otherwise, GL should already have free resources.\n      // (also workaround for https://github.com/stackgl/headless-gl/issues/90)\n      const { framebuffer, backbuffer, _shader } = this;\n      if (_shader) {\n        _shader.dispose();\n      }\n      if (framebuffer) {\n        framebuffer.dispose();\n      }\n      if (backbuffer) {\n        backbuffer.dispose();\n      }\n    }\n    delete this._shader;\n    delete this.framebuffer;\n    delete this.backbuffer;\n  }\n\n  _prepareGLObjects(gl: WebGLRenderingContext): void {\n    const [width, height] = this.getGLSize();\n    const { glParent, glSurface } = this.context;\n    if (glParent === glSurface) {\n      // my parent IS the glSurface, should prevent from creating a FBO.\n      // when a FBO is not created, _draw() happens on the final Canvas (null fbo)\n      // NB we can just do this in WillMount because this context will not change.\n      invariant(\n        !this.drawProps.backbuffering,\n        \"`backbuffering` is currently not supported for a Root Node. \" +\n          \"Try to wrap %s in a <LinearCopy> or <NearestCopy>.\",\n        this.getGLName()\n      );\n    } else {\n      const fbo = createFBO(gl, width, height);\n      this.framebuffer = fbo;\n      if (this.drawProps.backbuffering) {\n        const fbo = createFBO(gl, width, height);\n        this.backbuffer = fbo;\n      }\n    }\n  }\n\n  _onContextLost(): void {\n    this.dependencies.forEach(d => d._onContextLost());\n    this._destroyGLObjects();\n  }\n\n  _onContextRestored(gl: WebGLRenderingContext): void {\n    this._prepareGLObjects(gl);\n    this.dependencies.forEach(d => d._onContextRestored(gl));\n    this._needsRedraw = true;\n  }\n\n  _addGLNodeChild(node: Node) {}\n  _removeGLNodeChild(node: Node) {}\n\n  _addUniformBus(uniformBus: Bus, uniformName: string, index: number): void {\n    const array =\n      this.uniformsBus[uniformName] || (this.uniformsBus[uniformName] = []);\n    array[index] = uniformBus;\n  }\n\n  _removeUniformBus(uniformBus: Bus, uniformName: string, index: number): void {\n    const array =\n      this.uniformsBus[uniformName] || (this.uniformsBus[uniformName] = []);\n    if (array[index] === uniformBus) {\n      array[index] = null;\n    }\n  }\n\n  _addDependent(node: Node | Surface): void {\n    const i = this.dependents.indexOf(node);\n    if (i === -1) {\n      invariantNoDependentsLoop(this, node);\n      this.dependents.push(node);\n    }\n  }\n\n  _removeDependent(node: Node | Surface): void {\n    const i = this.dependents.indexOf(node);\n    if (i !== -1) {\n      this.dependents.splice(i, 1);\n    }\n  }\n\n  _syncDependencies(\n    newdeps: Array<Node | Bus>\n  ): [Array<Bus | Node>, Array<Bus | Node>] {\n    const olddeps = this.dependencies;\n    const additions = newdeps.filter(node => olddeps.indexOf(node) === -1);\n    const deletions = olddeps.filter(node => newdeps.indexOf(node) === -1);\n    additions.forEach(d => d._addDependent(this));\n    deletions.forEach(d => d._removeDependent(this));\n    this.dependencies = newdeps;\n    return [additions, deletions];\n  }\n\n  _bind(): void {\n    if (this.framebuffer) {\n      this.framebuffer.bind();\n    } else {\n      this.context.glSurface._bindRootNode();\n    }\n  }\n\n  _captureAlloc(size: number): Uint8Array {\n    let { capturePixelsArray } = this;\n    if (capturePixelsArray && size !== capturePixelsArray.length) {\n      pool.freeUint8(capturePixelsArray);\n      capturePixelsArray = null;\n    }\n    const pixels: Uint8Array = capturePixelsArray || pool.mallocUint8(size);\n    this.capturePixelsArray = pixels;\n    return pixels;\n  }\n\n  _latestShaderInfo: ?ShaderInfo;\n  _shader: ?Shader; // in case of inline shader, a Node currently hold a Node\n\n  _getShader(shaderProp: mixed): Shader {\n    const { glSurface } = this.context;\n    const nodeName = this.getGLName();\n    invariant(shaderProp, nodeName + \": shader prop must be provided\");\n    if (isShaderIdentifier(shaderProp)) {\n      // $FlowFixMe\n      return glSurface._getShader(shaderProp);\n    }\n\n    const shaderInfo = shaderDefinitionToShaderInfo(\n      ensureShaderDefinition(shaderProp, \" in \" + nodeName)\n    );\n    const latestShaderInfo = this._latestShaderInfo;\n    let shader = this._shader;\n    if (\n      !shader ||\n      !latestShaderInfo ||\n      !shaderInfoEquals(latestShaderInfo, shaderInfo)\n    ) {\n      if (shader) {\n        shader.dispose();\n        delete this._shader;\n      }\n      shader = glSurface._makeShader(shaderInfo);\n      this._latestShaderInfo = shaderInfo;\n      this._shader = shader;\n    }\n    return shader;\n  }\n\n  _draw(): void {\n    const { glSurface } = this.context;\n    const { gl } = glSurface;\n    const visitors = glSurface.getVisitors();\n    const nodeName = this.getGLName();\n    if (!gl || !this._needsRedraw) {\n      visitors.forEach(v => v.onNodeDrawSkipped(this));\n      return;\n    }\n\n    const {\n      backbuffering,\n      uniforms,\n      uniformsOptions,\n      shader: shaderProp,\n      blendFunc,\n      clear,\n      onDraw\n    } = this.drawProps;\n\n    //~ PREPARE phase\n\n    if (!this.framebuffer) {\n      const { glSizable } = this.context;\n      const [width, height] = glSizable.getGLSize();\n      const [nw, nh] = this.getGLSize();\n      invariant(\n        nw === width && nh === height,\n        nodeName +\n          \" is root but have overrided {width=%s,height=%s} which doesn't match Surface size {width=%s,height=%s}. \" +\n          \"Try to wrap your Node in a <NearestCopy> or <LinearCopy>\",\n        nw,\n        nh,\n        width,\n        height\n      );\n    }\n\n    const shader = this._getShader(shaderProp);\n\n    this._needsRedraw = false; // FIXME what's the correct position of this line?\n\n    const { types } = shader;\n    const glRedrawableDependencies: Array<Node | Bus> = [];\n    const pendingTextures: Array<Promise<*>> = [];\n    let units = 0;\n    const usedUniforms = Object.keys(types.uniforms);\n    const providedUniforms = Object.keys(uniforms);\n    const { uniformsBus } = this;\n    for (let k in uniformsBus) {\n      if (!(k in uniforms)) {\n        providedUniforms.push(k);\n      }\n    }\n    const textureUnits: Map<WebGLTexture, number> = new Map();\n\n    const prepareTexture = (\n      initialObj: mixed,\n      uniformOptions: ?$Shape<TextureOptions>,\n      uniformKeyName: string\n    ) => {\n      let obj = initialObj,\n        dependency: ?(Node | Bus),\n        result: ?{\n          directTexture?: ?WebGLTexture,\n          directTextureSize?: ?[number, number],\n          glNode?: Node,\n          glNodePickBackbuffer?: boolean\n        };\n\n      if (typeof obj === \"function\") {\n        // texture uniform can be a function that resolves the object at draw time.\n        obj = (obj: AsyncMixed)(this.redraw);\n      }\n\n      if (!obj) {\n        if (obj === undefined) {\n          console.warn(\n            `${nodeName}, uniform '${uniformKeyName}' is undefined.` +\n              \"If you explicitely want to clear a texture, set it to null.\"\n          );\n        }\n      } else if (isBackbuffer(obj)) {\n        // maybe it's backbuffer?\n        if (!this.drawProps.backbuffering) {\n          console.warn(\n            `${nodeName}, uniform ${uniformKeyName}: you must set \\`backbuffering\\` on Node when using Backbuffer`\n          );\n        }\n        result = { glNode: this, glNodePickBackbuffer: true };\n      } else if (isBackbufferFrom(obj)) {\n        // backbuffer of another node/bus\n        invariant(\n          typeof obj === \"object\",\n          \"invalid backbufferFromNode. Got: %s\",\n          obj\n        );\n        let node = obj.node;\n        if (node instanceof Bus) {\n          node = node.getGLRenderableNode();\n          invariant(\n            node,\n            \"backbufferFromNode(bus) but bus.getGLRenderableNode() is %s\",\n            node\n          );\n        }\n        invariant(\n          node instanceof Node,\n          \"invalid backbufferFromNode(obj): obj must be an instanceof Node or Bus. Got: %s\",\n          obj\n        );\n        if (!node.drawProps.backbuffering) {\n          console.warn(\n            `${nodeName}, uniform ${uniformKeyName}: you must set \\`backbuffering\\` on the Node referenced in backbufferFrom(${node.getGLName()})`\n          );\n        }\n        result = { glNode: node, glNodePickBackbuffer: true };\n      } else if (obj instanceof Node) {\n        // maybe it's a Node?\n        dependency = obj;\n        result = { glNode: obj };\n      } else if (obj instanceof Bus) {\n        // maybe it's a Bus?\n        // to a node?\n        const node = obj.getGLRenderableNode();\n        if (node) {\n          dependency = node;\n          result = { glNode: node };\n        } else {\n          // to a DOM/native element? (like <canvas>, <video>, ...)\n          dependency = obj;\n          const renderable: ?Element = obj.getGLRenderableContent();\n          if (!renderable) {\n            console.warn(\n              `${nodeName}, uniform ${uniformKeyName}: child is not renderable. Got:`,\n              renderable\n            );\n            result = { directTexture: null };\n          } else {\n            obj = renderable;\n          }\n        }\n      }\n\n      // In any remaining cases, we are asking texture loaders\n      // to concretely resolve the Texture.\n      if (!result && obj) {\n        const { loader, input } = glSurface._resolveTextureLoader(obj);\n        if (!loader) {\n          console.warn(\n            `${nodeName}, uniform ${uniformKeyName}: no loader found for value`,\n            input,\n            obj\n          );\n        } else {\n          const t = loader.get(input);\n          if (t) {\n            result = {\n              directTexture: t,\n              directTextureSize: loader.getSize(input)\n            };\n          } else {\n            // otherwise, we will have to load it and postpone the rendering.\n            const d = loader.load(input);\n            pendingTextures.push(d.promise);\n          }\n        }\n      }\n\n      // we also accumulate a dep, that will be used to build the gl graph.\n      if (dependency) glRedrawableDependencies.push(dependency);\n\n      const textureOptions = result ? uniformOptions : null;\n      const getMetaInfo = () => ({\n        initialObj,\n        obj,\n        dependency,\n        textureOptions\n      });\n      const getSize = (): ?[number, number] => {\n        const fallback = [2, 2];\n        return result\n          ? \"directTextureSize\" in result\n            ? result.directTextureSize\n            : result.glNode ? result.glNode.getGLSize() : fallback\n          : fallback;\n      };\n      const prepare = () => {\n        const texture: WebGLTexture =\n          (result &&\n            (result.directTexture ||\n              (result.glNode &&\n                (result.glNodePickBackbuffer\n                  ? result.glNode.getGLBackbufferOutput()\n                  : result.glNode.getGLOutput())))) ||\n          glSurface.getEmptyTexture();\n        if (textureUnits.has(texture)) {\n          // FIXME different uniform options on a same texture is not supported\n          return textureUnits.get(texture);\n        }\n        const value = units++;\n        gl.activeTexture(gl.TEXTURE0 + value);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        applyTextureOptions(gl, textureOptions);\n        textureUnits.set(texture, value);\n        return value;\n      };\n      return {\n        getMetaInfo,\n        getSize,\n        prepare\n      };\n    };\n\n    const prepareUniform = key => {\n      const uniformType = types.uniforms[key];\n      if (!uniformType) {\n        console.warn(\n          `${nodeName} uniform '${key}' is not declared, nor used, in your shader code`\n        );\n      }\n      const uniformValue = uniforms[key];\n      usedUniforms.splice(usedUniforms.indexOf(key), 1);\n\n      if (uniformType === \"sampler2D\") {\n        const uniformBus = uniformsBus[key];\n        const { getMetaInfo, prepare } = prepareTexture(\n          (uniformBus && uniformBus[0]) || uniformValue,\n          uniformsOptions[key],\n          key\n        );\n        return {\n          key,\n          type: uniformType,\n          getMetaInfo,\n          prepare\n        };\n      } else if (uniformValue === Uniform.Resolution) {\n        return {\n          key,\n          type: uniformType,\n          value: this.getGLSize()\n        };\n      } else if (isTextureSizeGetter(uniformValue)) {\n        invariant(\n          uniformValue && typeof uniformValue === \"object\",\n          \"unexpected textureSize object. Got: %s\",\n          uniformValue\n        );\n        const { getSize } = prepareTexture(uniformValue.obj, null, key);\n        const size = getSize();\n        if (!size) {\n          console.warn(\n            `${nodeName}, uniform ${key}: texture size is undetermined`\n          );\n        }\n        const value = uniformValue.ratio\n          ? size ? size[0] / size[1] : 1\n          : size || [0, 0];\n        return {\n          key,\n          type: uniformType,\n          value\n        };\n      } else if (Array.isArray(uniformType) && uniformType[0] === \"sampler2D\") {\n        let values;\n        const uniformBus = uniformsBus[key];\n        const v = mergeArrays(\n          Array.isArray(uniformValue) ? uniformValue : [],\n          Array.isArray(uniformBus) ? uniformBus : []\n        );\n        if (!v.length) {\n          console.warn(\n            `${nodeName}, uniform '${key}' should be an array of textures.`\n          );\n          values = uniformType.map(() => null);\n        } else if (v.length !== uniformType.length) {\n          console.warn(\n            `${nodeName}, uniform '${key}' should be an array of exactly ${uniformType.length} textures (not ${v.length}).`\n          );\n          values = uniformType.map(() => null);\n        } else {\n          values = v;\n        }\n\n        const uniformOptions = uniformsOptions[key]; // TODO support array of options as well\n        const all = values.map((value, i) =>\n          prepareTexture(value, uniformOptions, key + \"[\" + i + \"]\")\n        );\n\n        return {\n          key,\n          type: uniformType,\n          getMetaInfo: () =>\n            all.reduce((acc, o) => acc.concat(o.getMetaInfo()), []),\n          prepare: () => all.map(o => o.prepare())\n        };\n      } else {\n        if (uniformValue === undefined) {\n          console.warn(`${nodeName}, uniform '${key}' is undefined.`);\n        }\n        return {\n          key,\n          type: uniformType,\n          value: uniformValue\n        };\n      }\n    };\n    const preparedUniforms = providedUniforms.map(prepareUniform);\n\n    if (usedUniforms.length !== 0) {\n      console.warn(\n        nodeName +\n          \": Missing uniforms: \" +\n          usedUniforms.map(u => `'${u}'`).join(\", \") +\n          \"\\n\" +\n          \"all uniforms must be provided \" +\n          \"because implementations might share and reuse a Shader Program\"\n      );\n    }\n\n    // if some textures are not ready, we freeze the rendering so it doesn't blink\n    if (pendingTextures.length > 0) {\n      Promise.all(pendingTextures).then(this.redraw);\n      // ^ FIXME \"cancel\" this promise if we ever come back in _draw()\n      visitors.forEach(v => v.onNodeDrawSkipped(this));\n      return;\n    }\n\n    //~ the draw will happen, there is no more interruption cases.\n    visitors.forEach(v => v.onNodeDrawStart(this));\n\n    const [additions, deletions] = this._syncDependencies(\n      glRedrawableDependencies\n    );\n    visitors.forEach(v => v.onNodeSyncDeps(this, additions, deletions));\n\n    if (backbuffering) {\n      // swap framebuffer and backbuffer\n      const { backbuffer, framebuffer } = this;\n      this.backbuffer = framebuffer;\n      if (backbuffer) {\n        this.framebuffer = backbuffer;\n      }\n    }\n\n    //~ DRAW dependencies step\n    const drawDep = d => d._draw();\n    this.dependencies.forEach(drawDep);\n\n    //~ DRAW this node step\n\n    visitors.forEach(v => v.onNodeDraw(this, preparedUniforms));\n\n    shader.bind();\n    this._bind();\n    preparedUniforms.forEach(obj => {\n      const value = obj.prepare ? obj.prepare() : obj.value;\n      if (value !== undefined) {\n        shader.uniforms[obj.key] = value;\n      }\n    });\n\n    if (blendFunc) {\n      const src = mapBlendFunc(gl, blendFunc.src);\n      const dst = mapBlendFunc(gl, blendFunc.dst);\n      if (src && dst) gl.blendFunc(src, dst);\n    }\n\n    if (clear) {\n      gl.clearColor(...clear.color);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n\n    if (onDraw) onDraw();\n\n    visitors.forEach(v => v.onNodeDrawEnd(this));\n  }\n}\n"]}