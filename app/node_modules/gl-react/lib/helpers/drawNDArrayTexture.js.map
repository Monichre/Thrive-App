{"version":3,"sources":["../../src/helpers/drawNDArrayTexture.js"],"names":["Buffer","global","isBuffer","b","isPacked","shape","stride","length","convertFloatToUint8","out","inp","muls","gl","texture","array","dtype","slice","maxSize","getParameter","MAX_TEXTURE_SIZE","Error","packed","type","FLOAT","UNSIGNED_BYTE","format","LUMINANCE","data","offset","ALPHA","LUMINANCE_ALPHA","RGB","RGBA","getExtension","buffer","buf_store","size","malloc","buf_array","assign","subarray","texImage2D","TEXTURE_2D","free"],"mappings":"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","file":"drawNDArrayTexture.js","sourcesContent":["//@flow\nimport type { NDArray } from \"ndarray\";\nimport ndarray from \"ndarray\";\nimport ops from \"ndarray-ops\";\nimport pool from \"typedarray-pool\";\n\nif (typeof Buffer === \"undefined\") {\n  global.Buffer = class Buffer {\n    // mock shim so pool don't crash..\n    static isBuffer = b => b instanceof Buffer;\n  };\n}\n\n// code is partly taken from https://github.com/stackgl/gl-texture2d/blob/master/texture.js\n\nfunction isPacked(shape, stride) {\n  if (shape.length === 3) {\n    return (\n      stride[2] === 1 &&\n      stride[1] === shape[0] * shape[2] &&\n      stride[0] === shape[2]\n    );\n  }\n  return stride[0] === 1 && stride[1] === shape[0];\n}\n\nfunction convertFloatToUint8(out, inp) {\n  ops.muls(out, inp, 255.0);\n}\n\nexport default (\n  gl: WebGLRenderingContext,\n  texture: WebGLTexture,\n  array: NDArray\n) => {\n  let dtype = array.dtype;\n  let shape = array.shape.slice();\n  let maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  if (\n    shape[0] < 0 ||\n    shape[0] > maxSize ||\n    shape[1] < 0 ||\n    shape[1] > maxSize\n  ) {\n    throw new Error(\"gl-react: Invalid texture size\");\n  }\n  let packed = isPacked(shape, array.stride.slice());\n  let type = 0;\n  if (dtype === \"float32\") {\n    type = gl.FLOAT;\n  } else if (dtype === \"float64\") {\n    type = gl.FLOAT;\n    packed = false;\n    dtype = \"float32\";\n  } else if (dtype === \"uint8\") {\n    type = gl.UNSIGNED_BYTE;\n  } else {\n    type = gl.UNSIGNED_BYTE;\n    packed = false;\n    dtype = \"uint8\";\n  }\n  let format = 0;\n  if (shape.length === 2) {\n    format = gl.LUMINANCE;\n    shape = [shape[0], shape[1], 1];\n    array = ndarray(\n      array.data,\n      shape,\n      [array.stride[0], array.stride[1], 1],\n      array.offset\n    );\n  } else if (shape.length === 3) {\n    if (shape[2] === 1) {\n      format = gl.ALPHA;\n    } else if (shape[2] === 2) {\n      format = gl.LUMINANCE_ALPHA;\n    } else if (shape[2] === 3) {\n      format = gl.RGB;\n    } else if (shape[2] === 4) {\n      format = gl.RGBA;\n    } else {\n      throw new Error(\"gl-texture2d: Invalid shape for pixel coords\");\n    }\n  } else {\n    throw new Error(\"gl-texture2d: Invalid shape for texture\");\n  }\n  if (type === gl.FLOAT && !gl.getExtension(\"OES_texture_float\")) {\n    type = gl.UNSIGNED_BYTE;\n    packed = false;\n  }\n  let buffer, buf_store;\n  let size = array.size;\n  if (!packed) {\n    let stride = [shape[2], shape[2] * shape[0], 1];\n    buf_store = pool.malloc(size, dtype);\n    let buf_array = ndarray(buf_store, shape, stride, 0);\n    if (\n      (dtype === \"float32\" || dtype === \"float64\") &&\n      type === gl.UNSIGNED_BYTE\n    ) {\n      convertFloatToUint8(buf_array, array);\n    } else {\n      ops.assign(buf_array, array);\n    }\n    buffer = buf_store.subarray(0, size);\n  } else if (array.offset === 0 && array.data.length === size) {\n    buffer = array.data;\n  } else {\n    buffer = array.data.subarray(array.offset, array.offset + size);\n  }\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    0,\n    format,\n    shape[0],\n    shape[1],\n    0,\n    format,\n    type,\n    buffer\n  );\n  if (buf_store) {\n    pool.free(buf_store);\n  }\n};\n"]}