{"version":3,"sources":["../src/Bus.js"],"names":["Bus","id","dependents","glNode","onRef","ref","glBusRootNode","redraw","forEach","d","_draw","props","uniform","index","glParent","context","_addUniformBus","_removeUniformBus","oldUniform","oldIndex","node","i","indexOf","push","splice","mapRenderableContent","glSurface","getGLName","String","getGLRenderableContent","content","shortContentName","constructor","name","getGLShortName","x","y","w","h","capture","_onContextLost","gl","_onContextRestored","children","RenderLessElement","undefined","defaultProps","contextTypes","object","isRequired","childContextTypes"],"mappings":"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","file":"Bus.js","sourcesContent":["//@flow\nimport invariant from \"invariant\";\nimport React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport Node from \"./Node\";\nimport invariantNoDependentsLoop from \"./helpers/invariantNoDependentsLoop\";\nimport genId from \"./genId\";\nimport type { Surface } from \"./createSurface\";\nimport type { NDArray } from \"ndarray\";\n\ntype Props = {|\n  children?: React.Element<*> | ((redraw?: () => void) => React.Element<*>),\n  uniform?: string,\n  index: number\n|};\n\n/**\n * a **Bus is a container to \"cache\" and re-use content** (tree of Node, canvas, video,...) somewhere else in your GL graph.\n * To use it, use the Bus `ref`:\n * - provide it in another Node texture uniform so you can share computation (send a Node texture to multiple Nodes dependent) (more exactly, a working pattern is to give a `()=>ref` function that will be resolved in `DidUpdate` lifecycle)\n * - You have a `capture()` method to snapshot the underlying Node (because Node can be hidden being nested React components).\n *\n *\n * @prop {any} children the content to render. It can also be a function that takes a redraw function and render an element.\n * @prop {string} [uniform] In case you want to explicitely draw Bus directly into a uniform, you can give the uniform name of the parent node.\n * If this prop is not used, the Bus does not directly belong to a Node and a ref can be used to indirectly give a texture to a node.\n * `uniform` is equivalent to directly pass your VDOM inside the Node uniforms prop.\n *\n * **Usage Example**\n *\n * [![](https://github.com/ProjectSeptemberInc/gl-react/raw/master/docs/examples/blur.gif)](/blurmapmouse)\n *\n * @example\n *\n * <Surface ...>\n *   <Bus ref=\"myBus\">\n *     //here, glEffects or content like a canvas/video...\n *   </Bus>\n *   <Node uniforms={{\n *     texture: () => this.refs.myBus\n *   }} ... />\n * </Surface>\n *\n */\nexport default class Bus extends Component<{ index: number }, Props, void> {\n  id: number = genId();\n  props: Props;\n  context: {\n    glParent: Surface | Node,\n    glSurface: Surface\n  };\n  dependents: Array<Node | Surface> = [];\n\n  static defaultProps = {\n    index: 0\n  };\n\n  static contextTypes = {\n    glParent: PropTypes.object.isRequired,\n    glSurface: PropTypes.object.isRequired\n  };\n\n  static childContextTypes = {\n    glParent: PropTypes.object.isRequired\n  };\n\n  componentWillMount() {\n    const { uniform, index } = this.props;\n    if (uniform) {\n      const { glParent } = this.context;\n      invariant(\n        glParent instanceof Node,\n        'a <Bus uniform=\"..\" /> needs to be inside a Node'\n      );\n      glParent._addUniformBus(this, uniform, index);\n    }\n  }\n\n  componentWillUnmount() {\n    const { uniform, index } = this.props;\n    if (uniform) {\n      const { glParent } = this.context;\n      invariant(\n        glParent instanceof Node,\n        'a <Bus uniform=\"..\" /> needs to be inside a Node'\n      );\n      glParent._removeUniformBus(this, uniform, index);\n    }\n  }\n\n  componentDidMount() {\n    this.redraw();\n  }\n\n  componentDidUpdate() {\n    this.redraw();\n  }\n\n  componentWillReceiveProps({ uniform, index }: Props) {\n    const { uniform: oldUniform, index: oldIndex } = this.props;\n    if (uniform && (uniform !== oldUniform || index !== oldIndex)) {\n      const { glParent } = this.context;\n      invariant(\n        glParent instanceof Node,\n        'a <Bus uniform=\"..\" /> needs to be inside a Node'\n      );\n      if (oldUniform) glParent._removeUniformBus(this, oldUniform, oldIndex);\n      glParent._addUniformBus(this, uniform, index);\n    }\n  }\n\n  getChildContext(): { glParent: Bus } {\n    return {\n      glParent: this\n    };\n  }\n\n  glNode: ?Node = null;\n  _addGLNodeChild(node: Node) {\n    this.glNode = node;\n    this.context.glParent.redraw();\n  }\n  _removeGLNodeChild(node: Node) {\n    this.glNode = null;\n  }\n\n  _addDependent(node: Node | Surface) {\n    const i = this.dependents.indexOf(node);\n    if (i === -1) {\n      invariantNoDependentsLoop(this, node);\n      this.dependents.push(node);\n    }\n  }\n\n  _removeDependent(node: Node | Surface) {\n    const i = this.dependents.indexOf(node);\n    if (i !== -1) this.dependents.splice(i, 1);\n  }\n\n  getGLRenderableNode(): ?Node {\n    return this.glNode;\n  }\n\n  getGLRenderableContent(): mixed {\n    const { mapRenderableContent } = this.context.glSurface;\n    const { glBusRootNode } = this;\n    return glBusRootNode && mapRenderableContent\n      ? mapRenderableContent(glBusRootNode)\n      : null;\n  }\n\n  getGLName(): string {\n    return `Bus(${this.glNode\n      ? this.glNode.getGLName()\n      : String(this.getGLRenderableContent())})`;\n  }\n\n  getGLShortName(): string {\n    const content = this.getGLRenderableContent();\n    const shortContentName = String(\n      (content && content.constructor && content.constructor.name) || content\n    );\n    return `Bus(${this.glNode\n      ? this.glNode.getGLShortName()\n      : shortContentName})`;\n  }\n\n  /**\n   * Capture the underlying Node pixels.\n   * NB it only works for nodes, not for content like video/canvas.\n   */\n  capture(x?: number, y?: number, w?: number, h?: number): NDArray {\n    invariant(this.glNode, \"Bus does not contain any Node\");\n    return this.glNode.capture(x, y, w, h);\n  }\n\n  glBusRootNode: ?mixed;\n  onRef = (ref: mixed) => {\n    this.glBusRootNode = ref;\n  };\n\n  /**\n   * Schedule a redraw of all nodes that depends on this Bus.\n   *\n   * @function\n   */\n  redraw = () => {\n    this.dependents.forEach(d => d.redraw());\n  };\n\n  _onContextLost() {\n    const { glNode } = this;\n    if (glNode) glNode._onContextLost();\n  }\n\n  _onContextRestored(gl: WebGLRenderingContext) {\n    const { glNode } = this;\n    if (glNode) glNode._onContextRestored(gl);\n  }\n\n  _draw = () => {\n    // FIXME: _draw() on a Bus? (would a third party need this?)\n  };\n\n  render() {\n    const { children } = this.props;\n    const {\n      glSurface: { RenderLessElement, mapRenderableContent }\n    } = this.context;\n    return (\n      <RenderLessElement ref={mapRenderableContent ? this.onRef : undefined}>\n        {typeof children === \"function\" ? children(this.redraw) : children}\n      </RenderLessElement>\n    );\n  }\n}\n"]}